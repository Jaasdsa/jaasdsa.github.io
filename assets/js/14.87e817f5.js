(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{342:function(t,r,a){"use strict";a.r(r);var e=a(3),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"modbus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modbus"}},[t._v("#")]),t._v(" modbus")]),t._v(" "),a("h2",{attrs:{id:"应用层协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用层协议"}},[t._v("#")]),t._v(" 应用层协议")]),t._v(" "),a("p",[t._v("Modbus协议是OSI模型的"),a("code",[t._v("第七层")]),t._v("的应用层通讯协议，定义了不同类型设备间交换信息方式，以及信息的格式。"),a("br"),t._v(" "),a("img",{attrs:{src:"/img/gateway/modbusosi.png",alt:"image"}})]),t._v(" "),a("h2",{attrs:{id:"工作方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作方式"}},[t._v("#")]),t._v(" 工作方式")]),t._v(" "),a("p",[t._v("Modbus的工作方式是"),a("code",[t._v("请求")]),t._v("/"),a("code",[t._v("应答")]),t._v("，每次通讯都是主站先发送指令，可以是广播，或是向特定从站的单播，从站响应指令，并按要求应答，或者报告异常。当主站不发送请求时，从站不会自己发出数据，从站和从站之间不能直接通讯。")]),t._v(" "),a("h2",{attrs:{id:"工作模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作模式"}},[t._v("#")]),t._v(" 工作模式")]),t._v(" "),a("p",[t._v("分为"),a("code",[t._v("串行")]),t._v("和"),a("code",[t._v("TCP")]),t._v("，串行又分为"),a("code",[t._v("ASCII")]),t._v("和"),a("code",[t._v("RTU")]),t._v("。对于Modbus TCP而言，主站通常称为Client，从站称为Server；而对于Modbus RTU和Modbus ASCII来说，主站是Master，从站是Slave。Modbus TCP基于以太网和TCP/IP协议，Modbus RTU和Modbus ASCII则是使用异步串行传输（通常是RS-232/422/485）。")]),t._v(" "),a("h2",{attrs:{id:"协议内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协议内容"}},[t._v("#")]),t._v(" 协议内容")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://g.civnet.cn:8443/doc/software/raw/master/Modbus%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("协议内容下载地址"),a("OutboundLink")],1),t._v(" "),a("br"),t._v(" "),a("img",{attrs:{src:"/img/gateway/mod1.jpg",alt:"modbus1"}}),t._v(" "),a("img",{attrs:{src:"/img/gateway/mod2.jpg",alt:"modbus2"}}),t._v(" "),a("br"),t._v(" "),a("img",{attrs:{src:"/img/gateway/mod3.jpg",alt:"modbus3"}}),t._v(" "),a("img",{attrs:{src:"/img/gateway/mod4.jpg",alt:"modbus4"}})])]),t._v(" "),a("h2",{attrs:{id:"包格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包格式"}},[t._v("#")]),t._v(" 包格式")]),t._v(" "),a("p",[t._v("Modbus协议的报文（或帧）的基本格式是："),a("br"),t._v(" "),a("img",{attrs:{src:"/img/gateway/modbusContent.png",alt:"image"}})]),t._v(" "),a("ul",[a("li",[t._v("对TCP。Modbus On TCP给PDU加上表头，没有差错校验（因为下面的TCP是基于可靠的连接），然后交给TCP层。")]),t._v(" "),a("li",[t._v("对serial。PDU被直接交给Modbus链路层加上表头和校验码。表头包含Modbus从站地址，RTU用CRC校验，ASCII用LRC校验。\n表头包含了从站的地址，功能码告诉从站要执行何种功能，数据区是具体的信息。")])]),t._v(" "),a("p",[t._v("先以RTU为例，主站发送了：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("09 03 00 04 00 03 XX YY\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v('主站告诉从站09，我要做"03"操作，即读Holding Register内容，开始偏移地址为4、长度为3。因为Holding Register的有效地址范围是40001-49999，开始偏移地址4、长度为3即地址40005、40006、40007的值。"XXYY"代表RTU的校验位CRC。\n从站收到信息后，就从对应的寄存器找到数值，回复：')]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("09 03 06 02 2B 00 01 00 64 XX YY\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v('从站回答，该地址偏移为4的寄存器值为02 2B，地址偏移为5的寄存器值为00 01，地址偏移为6的寄存器值为00 64。其中"09 03"是复制了主站发来的地址和功能码，"06"代表接下来的数据共有6个字节。\n如果从站收到了一个错误的请求，例如发现要读的寄存器地址是错误的，则回复：09 83 02 XX YY\n其中"83"是把功能码"03"的最高位置1，告诉主站发生了异常，"02"是异常码，说明发生了无效地址的异常。\n#Modbus的四种数据类型')]),t._v(" "),a("ul",[a("li",[t._v("Coil：可读可写bit，既可以是一个输出量输出点，也可以是数字量输入点，有效的地址范围是1-9999。")]),t._v(" "),a("li",[t._v("Input Status：只读bit，即数字量输出点，有效地址范围是10001-19999。")]),t._v(" "),a("li",[t._v("Input Register：只读word，可以用作模拟量或16位打包输入点，有效地址范围是30001-39999。")]),t._v(" "),a("li",[t._v("Holding Register：可读可写word，既可以是一个模拟量或16位打包输入点，也可以是模拟量或16位打包输出点，有效地址范围是40001-49999。")])]),t._v(" "),a("p",[t._v("在PLC或DCS上用点名标记不同的变量，在Modbus则以数据地址来标记每个点。以上所说的地址都是参考地址，而不是实际的物理地址。上述的地址是在设备中的地址，按照"),a("code",[t._v("PLC的习惯从1开始递增")]),t._v("，而Modbus报文中是从0开始递增。例如地址偏移为4、5、6的Holding Register，其实是指参考地址是40005、40006、40007的寄存器。\n#TCP、Serial的区别\n对于Modbus TCP而言，主站通常称为Client，从站称为Server；而对于Modbus RTU和Modbus ASCII来说，主站是Master，从站是Slave。Modbus TCP端口号是502"),a("br"),t._v(" "),a("a",{attrs:{href:"http://www.ip33.com/crc.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("CRC循环校验"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"rtu和ascii的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rtu和ascii的区别"}},[t._v("#")]),t._v(" RTU和ASCII的区别")]),t._v(" "),a("p",[t._v("RTU模式下，一个字节的数据，传输的就是一个字节。ASCII模式下，同样一个字节数据用了两个字节来传输。\n例如，要传输数字0x5B，RTU传输的是0101 1011（二进制），而ASCII传输的是00110101（53，ASCII的5的码是53）和01000010。可见，ASCII传输的速率是RTU的一半。ASCII模式采用LRC校验，RTU模式采用16位CRC校验。")]),t._v(" "),a("h2",{attrs:{id:"modbus-slave-poll"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modbus-slave-poll"}},[t._v("#")]),t._v(" modbus Slave&Poll")]),t._v(" "),a("ul",[a("li",[t._v("使用教程:"),a("a",{attrs:{href:"https://www.cnblogs.com/hieroly/p/9063710.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考链接"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("下载地址：\n"),a("a",{attrs:{href:"https://g.civnet.cn:8443/doc/software/raw/master/ModbusPollSalveSN.rar",target:"_blank",rel:"noopener noreferrer"}},[t._v("modbus Slave&Poll"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://g.civnet.cn:8443/doc/software/raw/master/virtualserialportdriver8.rar",target:"_blank",rel:"noopener noreferrer"}},[t._v("虚拟串口"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=s.exports}}]);